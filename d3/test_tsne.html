<head>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src='https://raw.githack.com/karpathy/tsnejs/master/tsne.js'></script>
<script src="http://d3js.org/queue.v1.min.js"></script>

<style>
            /* tell the SVG path to be a thin blue line without any area fill */

				path { 
						stroke-width: 1; fill: none; 
				} 
				.line_hover { 
						stroke: orange; stroke-width: 3;
				} 
				.line {
            stroke: black; 
				}
				.line_brush {
            stroke: black; 
				}  
				.axis { 
						shape-rendering: crispEdges; 
				} 
				.x.axis line {
            stroke: lightgrey; 
				} .x.axis 
				.minor { stroke-opacity: .5; 
				} 
				.x.axis path
            { display: none; 
				} 
				.x.axis text { font-size: 14; 
				} 
				.y.axis line, .y.axis
            path { fill: none; stroke: #000; } .y.axis text { font-size: 14; } .y.axisRight
            text { fill: orange; } .y.axisLeft text { fill: steelblue; } 

				
				.button {
            position: absolute;
            top: 15px;
            left: 130px;
         }

				.text-input {
            position: absolute;
            top: 15px;
            left: 430px;
         }

				.viewport {
            position: absolute;
            top: 45px;
            left: 15px;
            overflow: scroll;
            width: 560px;
            height: 600px;
            background-color: #e8e8e8;
            border: 1px solid #AAAAAA;
            border-radius: 4px;
            box-shadow: inset 1px 1px 6px 2px rgba(0,0,0, .25);
        }

				.tsne {
            position: absolute;
            top: 70px;
            left: 600px;
            width: 550px;
            height: 460px;
        }

				.raw_signal {
            position: absolute;
            top: 500px;
            left: 550px;
            width: 350px;
            height: 400px;
        }

				div.tooltip {	
    				position: absolute;			
    				text-align: center;			
    				width: 100px;					
    				height: 58px;					
    				padding: 2px;				
    				font: 12px sans-serif;		
    				background: lightsteelblue;	
    				border: 0px;		
   				 	border-radius: 8px;			
    				pointer-events: none;			
				}

				.brushed {
            opacity: 1.0;
        }

        .non_brushed {
            opacity: 0.6;
        }

</style>
</head>

<body>
<div class = "button">
	<form id="sort">
	<div> Sort by
		<input type='radio' id="kmer" name="mode" checked>kmer</input> 
		<input  type='radio' id="median" name="mode">median</input>
		<input  type='radio' id="max" name="mode">max</input>
  </div>
	</form>
</div>

<div class = "text-input">
	<form name="myform" onSubmit="return handleClick()">
    <input name="Submit"  type="submit" value="Get t-SNE plot" >
    <input type="text" id="myVal1" placeholder="Kmer1">
		<input type="text" id="myVal2" placeholder="Kmer2">
		<!--<input type="text" id="myVal3" placeholder="Kmer3">
		<input type="text" id="myVal4" placeholder="Kmer4">-->
  </form>
</div>

<div class = "viewport"></div>
<div class = "tsne"></div>
<div class = "raw_signal"></div>

<script type="text/javascript">

var current_kmer = 'AACAA'  // initial kmer. will change on dropdown
var dropdownChange = function(){
			var new_kmer = d3.select(this).property('value'),
					newfile = './data/dist_matrix/'+new_kmer+'.csv'
					update_tsne(newfile, new_kmer)
			current_kmer = new_kmer

}

var opt = {epsilon: 10}; // epsilon is learning rate (10 = default)
var tsne = new tsnejs.tSNE(opt); // create a tSNE instance

// get positions of the t-sne plot before passing it to draw_tsne
/* 
var update_tsne = function(filename, new_kmer) {
	d3.csv(filename, function(data) {
			
			//for(i=0; i<data.columns.length;i++){data.forEach(function(d){ d[data.columns[i]] = +d[data.columns[i]]; });}

			var dists = data.map(obj => Object.values(obj));

			tsne.initDataDist(dists);
			for(var k = 0; k < 500; k++) {
  			tsne.step(); // every time you call this, solution gets better
			}
			var Y = tsne.getSolution(); 
			
			draw_tsne(Y)
	})
} */

// uncomment to display dropdown menu
/*var dropdown = d3.select("body")
				.insert("select", "svg")
				.on("change",dropdownChange);*/

// get values for the dropdown menu
var kmerValues = []
d3.csv('./data/kmer_list.csv', function(data) {

	kmerValues = data	

	var kmerValues = data.map(d => d['kmer'])

	dropdown.selectAll('option')
				.data(kmerValues)
			.enter().append('option')
				.attr('value', function(d) {return d; })
				.text(function(d) {return d; });
		var initialData = './data/dist_matrix/AACAA.csv'
		//update_tsne(initialData)
})

// draw t-sne
function draw_tsne(position, kmer1, kmer2) {
		kmer1_pos = position.slice(0,5)
		console.log(kmer1_pos)
		var width = 600;
		var height = 500;
		var padding = 65;
		
		d3.select('#tsne').remove()
		var svg = d3.select('.tsne')
				.append('svg')
				.attr("width", width)
        .attr("height", height)
				.attr("id", "tsne")		

		var xScale = d3.scaleLinear()
				.domain(d3.extent(position, function(d) {return d[0];	}))	
				.range([padding,width - padding * 2])
				.nice();

		var yScale = d3.scaleLinear()
				.domain(d3.extent(position, function(d) {return d[1]; }))
				.range([height - padding, padding])
				.nice();  

		var brush = d3.brush()
									//.extent([[0, 0], [100, 100]])
									.on("brush", highlightBrushedCircles)
									.on("end", endBrush)

		d3.select('#tsne').append("g")
				.call(brush)

		var circles = svg.append("g")
				.selectAll('circle')
			  .data(position)
			  .enter()
			  .append('circle')
				.attr('x', function(d) {
						return xScale(d[0]);
				})	
				.attr('y', function(d) {
						return yScale(d[1]);
				})
				.attr('r', 6)
				.attr('cx', function(d) {
						return xScale(d[0]);
				})
				.attr('cy', function(d) {
						return yScale(d[1]);
				})
				.attr("class", "non_brushed")
				//.style('fill', function(d) { if (kmer1_pos.includes(d)) {return "blue";} })
				.style('fill', function(d,i) { 
												if (i < position.length/2) {
													return "limegreen";
												} else {
													return "royalblue";
												}
				})
				.on('click',function(d,i){
												if (d3.select(this).style("fill") == "limegreen") { 
													d3.select(this).style("fill", "darkgreen");
												}	else {
													d3.select(this).style("fill", "darkblue");
												}
												
												add_signal(i, kmer1, kmer2);
												
				})
				/*.on('mouseover', function(d,i){
												if (d3.select(this).style("fill") == "steelblue") {
													d3.select(this).style("fill", "red");
												} else {
													d3.select(this).style("fill", "orange");
												}*/
												
				.on('mouseover', function(d,i){
													
												//d3.select(this).style("fill", "red");
												d3.select(this).attr("r", "10");
												add_signal_hover(i, kmer1, kmer2);
				
												
				})
				.on('mouseout', function(d,i){
												//if (d3.select(this).style("fill") == "steelblue") {
												/*if (d3.select(this).style("fill") == "red" && i < position.length/2) {
													d3.select(this).style("fill", "limegreen");
												} else if (d3.select(this).style("fill") == "red" && i > position.length/2) {
													d3.select(this).style("fill", "royalblue");
												} */
												d3.select(this).attr("r", "6");
												remove_signal_hover();
												
				})

		function highlightBrushedCircles() {

        if (d3.event.selection != null) {

           // revert circles to initial style
           circles.attr("class", "non_brushed");

           var brush_coords = d3.brushSelection(this);

           // style brushed circles
           circles.filter(function (){

           						var cx = d3.select(this).attr("cx"),
                          cy = d3.select(this).attr("cy");

                      return isBrushed(brush_coords, cx, cy);
                  })
                  .attr("class", "brushed");
					
         }
				
				 	
    }

		function endBrush() {
				// disregard brushes w/o selections
				if (!d3.event.selection) return;

				// programmed clearing of brush after mouse-up
				//d3.select(this).call(brush.move, null);
				
				//get indices for the brushed points
        var d_brushed =  d3.selectAll(".brushed").data();			
				var row_list = []				
				if (d_brushed.length > 0 && row_list.length ==0) {
            
            d_brushed.forEach(d_each => row_list.push(position.indexOf(d_each)))
					
        } 
				add_signal_brush(row_list, kmer1, kmer2)
		}		
}

function isBrushed(brush_coords, cx, cy) {

     var x0 = brush_coords[0][0],
         x1 = brush_coords[1][0],
         y0 = brush_coords[0][1],
         y1 = brush_coords[1][1];
	
      return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
}

// add new signals to data array and then pass it to draw_signal 
var data = []
var data_hover = []
var data_row = []
var data_brush = []


function add_signal_brush(row_list, kmer1, kmer2) {
	filename1 = './data/raw_signal/'+kmer1+'_signal.csv';
	filename2 = './data/raw_signal/'+kmer2+'_signal.csv';

	queue()
		.defer(d3.csv, filename1)
		.defer(d3.csv, filename2)
		.await(add)
	
	function add(error, file1, file2){
			d = file1.concat(file2)
			if (data_brush.length >0){
					data_brush.length = 0
			}
			for (i=0;i<row_list.length;i++){
					row = row_list[i]
					data_brush.push(d[row]['values'].split("_").map(Number))
			}
			
			console.log(data_brush)			
			draw_signal(data, data_hover, data_brush)
	
	}
}

function add_signal(row, kmer1, kmer2){
//filename = './data/raw_signal/'+current_kmer+'_signal.csv'

filename1 = './data/raw_signal/'+kmer1+'_signal.csv';
filename2 = './data/raw_signal/'+kmer2+'_signal.csv';

queue()
	.defer(d3.csv, filename1)
	.defer(d3.csv, filename2)
	.await(add)

	function add(error, file1, file2){
			d = file1.concat(file2)
	//d3.csv(filename, function(d){
			if (data_row.includes(row)) {
					index = data_row.indexOf(row)
					data_row.splice(index, 1)
					data.splice(index, 1)

			} else {
					data_row.push(row)
					data.push(d[row]['values'].split("_").map(Number))		

			}
			
			draw_signal(data, data_hover, data_brush)
	//})
	}
}

var signalToAdd = null;

function add_signal_hover(row, kmer1, kmer2){
//filename = './data/raw_signal/'+current_kmer+'_signal.csv';
filename1 = './data/raw_signal/'+kmer1+'_signal.csv';
filename2 = './data/raw_signal/'+kmer2+'_signal.csv';

queue()
	.defer(d3.csv, filename1)
	.defer(d3.csv, filename2)
	.await(add)

current_kmer = kmer1+'_'+kmer2
signalToAdd = current_kmer + '_' + row;

	function add(error, file1, file2){
			d = file1.concat(file2)
	//d3.csv(filename, function(d){
					d3.selectAll('.line_hover').remove();

					if (signalToAdd == current_kmer + '_' + row)
					{
						data_hover.push(d[row]['values'].split("_").map(Number))
						draw_signal(data, data_hover, data_brush)
						
					}
	//})
	}
}

function remove_signal_hover(){
	
	//draw_signal(data, data_hover)
	data_hover = []
	d3.selectAll('.line_hover').remove();
	signalToAdd=null;
}

var div = d3.select("body").append("div")	
    .attr("class", "tooltip")				
    .style("opacity", 0);

d3.csv('./data/boxplot_data.csv', function(data) {
		
		function changeBoxplot(){
			d3.select(".viewport").selectAll("*").remove()
			var form = document.getElementById("sort")
			var form_val;
			for(var i=0; i<form.length; i++){
      	  if(form[i].checked){
      	    form_val = form[i].id;}} 
			
			draw_boxplot(data, form_val)
		}

		var dataDim = d3.select("#sort")
		dataDim.on("change", changeBoxplot)
		draw_boxplot(data, 'kmer')
})

function draw_boxplot(data, form_val) {
		if (form_val == 'median') {
			data.forEach(function(data){ data['median']= +data['median'];});
			
				data.sort(function(a,b) {
    			return b[form_val] - a[form_val];
				});
		}	else if (form_val == 'kmer') {
			
			data.sort(function(a,b) {
    		var x = a[form_val].toLowerCase();
    		var y = b[form_val].toLowerCase();
    		return x < y ? -1 : x > y ? 1 : 0;
			});
		} else if (form_val == 'max') {
			data.forEach(function(data){ data['median']= +data['median'];});
			
				data.sort(function(a,b) {
    			return b[form_val] - a[form_val];
				});
		}
		
		var w = 550
		var h = 7500

		var margin = {
    top: 20,
    bottom: 20,
    left: 20,
    right: 30
  }

	d3.select('.viewport')
    .append('svg')
    .attr('height', h)
    .attr('width', w)

	var catVariable = 'order'
	var catValues = data.map(d => Number(d[catVariable]))
	var kmerValues = data.map(d => d['kmer'])

	const minVariable = 'min'
  const maxVariable = 'max'
  const medianVariable = 'median'
  const q1Variable = 'q1'
  const q3Variable = 'q3'

	var xScale = d3.scaleLinear()
			.domain([0,8000])
			.range([margin.left, w- margin.right-50])

	/*var yScale = d3.scaleLinear()
			.domain([
				Number(d3.max(data, d => d[catVariable])) + 1,
				Number(d3.min(data, d => d[catVariable])) - 1
			])
			.range([h - margin.bottom, margin.top])	
  */
	
	var yScale = d3.scalePoint()
			.domain(kmerValues)
			.range([h - margin.bottom, margin.top])
			.range([20, h])

	/*var xAxis = d3.axisBottom()
								.scale(xScale)
								.ticks(10)
								.tickSize(-470) 
				
	d3.select('svg')
		.append('g')
		.attr('transform', 'translate(0,480)')
		.attr('id', 'xAxisG')
		.call(xAxis) */

	var yAxis = d3.axisRight()
								.scale(yScale)
								.tickSize(-470)
    						//.tickValues(catValues)
								//.tickValues(kmerValues)
								
	
	d3.select('svg')
		.append('g')
		.attr('transform', 'translate(470,0)')
		.attr('id', 'yAxisG')
		.call(yAxis)

	d3.select('svg')
		.selectAll('g.box')
		.data(data)
		.enter()
		.append('g')
		.attr('class', 'box')
		.attr(
			'transform', d => `translate(${xScale(d[medianVariable])},${yScale(d['kmer'])})`
		)
		.on("mouseover", function(d) {
            div.transition()		
                .duration(200)		
                .style("opacity", 1);		
            div	.html('<strong>'+'median : '+'</strong>'+ d3.format(",.0f")(d.median) + "<br/>" +'<strong>'+'max : '+'</strong>'+d3.format(",.0f")(d.max) + "<br/>"  + '<strong>'+'min : '+'</strong>'+d3.format(",.0f")(d.min))	
                .style("left", (d3.event.pageX) + "px")		
                .style("top", (d3.event.pageY - 28) + "px");
									
     				})
		.on("mouseout", function(d) {		
            div.transition()		
                .duration(500)		
                .style("opacity", 0);	
        })	

		.each(function(d, i) {
			d3.select(this)
				.append('line')
				.attr('class', 'range')
				.attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
        .attr('y1', 0)
        .attr('y2', 0)
        .style('stroke', 'black')
        .style('stroke-width', '3px')

			d3.select(this)
        .append('line')
        .attr('class', 'max')
        .attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
        .attr('x2', xScale(d[maxVariable]) - xScale(d[medianVariable]))
        .attr('y1', -10)
        .attr('y2', 10)
        .style('stroke', 'black')
        .style('stroke-width', '3px')			

			d3.select(this)
				.append('line')
        .attr('class', 'min')
        .attr('x1', xScale(d[minVariable]) - xScale(d[medianVariable]))
        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
        .attr('y1', -10)
        .attr('y2', 10)
        .style('stroke', 'black')
        .style('stroke-width', '3px')

			d3.select(this)
        .append('rect')
        .attr('class', 'range')
        .attr('x', xScale(d[q1Variable]) - xScale(d[medianVariable]))
        .attr('y', -10)
        .attr('height', 20)
        .attr('width', xScale(d[q3Variable]) - xScale(d[q1Variable]))
        .style('fill', 'white')
        .style('stroke', 'black')
        .style('stroke-width', '3px')

			d3.select(this)
        .append('line')
        .attr('x1', 0)
        .attr('x2', 0)
        .attr('y1', -10)
        .attr('y2', 10)
        .style('stroke', 'darkgray')
        .style('stroke-width', '4px')


		})

}

// draw raw signals based on the data passed from add_signal
function draw_signal(data_click,data_hover, data_brush) {
	console.log(data_hover)
	//filename = './data/raw_signal/'+current_kmer+'_signal.csv'

	filename1 = './data/raw_signal/'+kmer1+'_signal.csv'
	filename2 = './data/raw_signal/'+kmer2+'_signal.csv'
	queue()
		.defer(d3.csv, filename1)
		.defer(d3.csv, filename2)
		.await(draw)
	
	//d3.csv(filename, function(d){
	function draw(error, file1, file2){
					d = file1.concat(file2)

					var data = data_hover.concat(data_click).concat(data_brush)
					
					var m = [80, 80, 80, 80]; // margins
        	var w = 700 - m[1] - m[3]; // width
        	var h = 300 - m[0] - m[2]; // height
        	 
        	
        	// X scale will fit all values from data[] within pixels 0-w
        	/*var x_max = 0;
        	for (var i = data_brush.length - 1; i >= 0; i--) {
        	    if (data_brush[i].length > x_max) x_max = data_brush[i].length;
        	};*/
        	var x = d3.scaleLinear()
						.domain([0, 300]) //set max value to fix the x-axis
						.range([0, w]);

        	// Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
        	
					var min = 999999;
					var max = 0;
					for (var i = data.length - 1; i >= 0; i--) {
        	    if(Math.max.apply(Math, data[i]) > max) max = Math.max.apply(Math, data[i])
							if(Math.min.apply(Math, data[i]) < min) min = Math.min.apply(Math, data[i])
        	};
					
        	var y = d3.scaleLinear().domain([min, max]).range([h, 0]); 
					
        	// automatically determining max range can work something like this
        	//var y = d3.scaleLinear().domain([0, d3.max(data_hover[0])]).range([h, 0]);

        	// create a line function that can convert data[] into x and y points
        	var line = d3.line()
        	// assign the X function to plot our line as we wish
        	.x(function(d, i) {
        	    
        	    // return the X coordinate where we want to plot this datapoint
        	    return x(i);
        	}).y(function(d) {
        	    
        	    // return the Y coordinate where we want to plot this datapoint
        	    return y(d);
        	})
        	// Add an SVG element with the desired dimensions and margin.
					d3.select(".raw_signal").selectAll('*').remove()
        	var graph = d3.select(".raw_signal")
						.append("svg:svg")
							.attr("width", w + m[1] + m[3])
							.attr("height", h + m[0] + m[2])
							.attr("id", "signal")
						.append("svg:g")
							.attr("transform", "translate(" + m[3] + "," + m[0] + ")")
						

        	// create xAxis
        	var xAxis = d3.axisBottom()
						.scale(x)
						.tickSize(-h)
						//.tickSubdivide(true);

        	// Add the x-axis.
        	graph.append("svg:g")
							.attr("class", "x axis")
							.attr("transform", "translate(0," + h + ")")
							.call(xAxis);
        	
					// add lines
        	// do this AFTER the axes above so that the line is above the tick-lines

					// signal plots for the clicked points
        	for (var i = data_click.length - 1; i >= 0; i--) {
        	    graph.append("svg:path")
									.attr("d", line(data_click[i]))
									.attr("class","line")
									.on("mouseover",function(d){d3.select(this).style("stroke-width",3)})
									.on("mouseout",function(d){d3.select(this).style("stroke-width",1)})
					};  
					
					// signal plot for the hovered point				
					for (var i = data_hover.length - 1; i >= 0; i--) {
							graph.append("svg:path")
									.attr("d", line(data_hover[i]))
									.attr("class","line_hover")
					};
				
					// signal plots for the brushed points
					console.log(data_brush)
					graph.selectAll(".line")
    					.data(data_brush)
  					.enter().append("path")
    					.attr("d", line)
    					.attr("class", "line_brush")
							.on("mouseover",function(d){d3.select(this).style("stroke-width",3)})
							.on("mouseout",function(d){d3.select(this).style("stroke-width",1)})


  //})
	}
}

function handleClick(event){
		kmer1 = document.getElementById("myVal1").value
		kmer2 = document.getElementById("myVal2").value


		// call a function to combine matrices
		combine_matrices(kmer1, kmer2)

		return false;
    
		
		
}

function combine_matrices(kmer1, kmer2){
		folder1 = './data/distance_matrices/'+kmer1
		folder2 = './data/distance_matrices/'+kmer2

		
		queue()
		.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer1 + '.csv')
		.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer2 + '.csv')
		.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer1 + '.csv')
		.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer2 + '.csv')
		
		.await(combine_csv)

	function combine_csv(error, file1, file2, file3, file4) {
		if(error) {console.log(error);}
		
		// Convert array of objects to array of arrays
		file1 = file1.map(obj => Object.values(obj));
		file2 = file2.map(obj => Object.values(obj));
		file3 = file3.map(obj => Object.values(obj));
		file4 = file4.map(obj => Object.values(obj));
		
		// column concat
		kmer1_row = file1.map((value,index) => { return value.concat(file2[index]) });
		kmer2_row = file3.map((value,index) => { return value.concat(file4[index]) });

		// row concat
		combined_matrix = kmer1_row.concat(kmer2_row)
		
		console.log(combined_matrix)
		
		// call update_tsne
		update_tsne(combined_matrix, kmer1, kmer2)
	}
}

var update_tsne = function(data, kmer1, kmer2) {
	
			
			//for(i=0; i<data.columns.length;i++){data.forEach(function(d){ d[data.columns[i]] = +d[data.columns[i]]; });}

			var dists = data.map(obj => Object.values(obj));

			tsne.initDataDist(dists);
			for(var k = 0; k < 500; k++) {
  			tsne.step(); // every time you call this, solution gets better
			}
			var Y = tsne.getSolution(); 
			
			draw_tsne(Y, kmer1, kmer2)
	
}


</script>
</body>
